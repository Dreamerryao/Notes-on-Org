### Chapter 3   Arithmetic for Computers  

#### Number

- 1word = 32bits ，word广泛应用于各种指令中
- 所有指令在读寄存器数据后都要进行alu运算
- 计算机处理的都是一串二进制数，代表什么含义看具体场景
- 2的补码是大家普遍接受的数的表示形式，其可以用唯一数学表达式来表示。
- 浮点数： IEEE 754
- 原码表示和反码表示：+0和-0不重合
- **注意： 1000 = -8，两个0重合多出来的位置分配给-2^n**

#### ALU（算逻单元）

- **Overflow**

  注意，两个无符号数相减，当减数大于被减数时，会将结果转换为有符号数，最高位代表符号位。

  溢出条件： 1.正+正<0 2.负+负>0 3.正-负<0 4.负-正>0

  **溢出的一种处理方式**：两位符号位，当这两位数值不等，即溢出

  硬件层面忽略Overflow，只给出溢出信号

- **哪些指令会产生溢出？**  ->add addi sub

- lbu指令:unsigned填充，前24位填0

  lb指令:signed填充，前24位填符号位

- **如何构造一个ALU？**

  ​	先设计一个一位的ALU部件，再进行一维调用(串行连接)形成阵列。

  ​	可以对进位传输进行优化(超前进位)，分组计算

  ​	slt构造：取减法结果的符号位，其他位都置0

  ​	具体实现可以用硬件代码实现，非常简单。

  ​	Function table

| ALU Control Lines | Functions |
| ----------------- | --------- |
| 000               | And       |
| 001               | Or        |
| 010               | Add       |
| 110               | Sub       |
| 111               | SLT       |
| 100               | nor       |
| 101               | srl       |
| 011               | sor       |



**寄存器操作数**

​	Register files:

​	支持2路读(rs,rt)，1路写(rd/rt),因此说寄存器操作是最快的

![image-20200524004500305](.\image-20200524004500305.png)

分成两个部分：

​	读取：

![image-20200524004706708](.\image-20200524004706708.png)

​	写入：

![image-20200524004732555](.\image-20200524004732555.png)

**乘法：**

- 密码学里的农夫乘法，通过左移右移一位来进行，32位数每步就需要三个步骤，判断，左移，右移，需要进行将近100个时间周期，太慢。

- 于是进行32位一组的优化，通过对结果和乘数的移位实现。

- 早期的优化都是从电路结构上来优化的。

- 随后进行优化：将乘数放在后32位中，因为会被移位出去。(**这里的移位都是算数移位**)

- Booth 算法，对一串连续1有很好的优化效果举例011100->100000-000100

  Booth算法需要看两位：current last ，第一位时规定Bit-1 = 0

  10：sub  11:shift  01: add  00 : shift



**除法：**

- 被除数<除数 ->放余数
- 迭代的进行减法操作，其中移位操作与乘法十分相似
- 十进制的长除很复杂，但二进制非0即1
- 注意MIPS中乘除法完成后，mflo/mfhi指令复制结果到某寄存器中